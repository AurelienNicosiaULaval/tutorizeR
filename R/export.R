# Export helpers ----------------------------------------------------------

#' Export a profile-aware LMS manifest
#'
#' @param input Source `.Rmd`/`.qmd` file.
#' @param output_file Optional output path. Default uses input stem.
#' @param profile Manifest profile (`"generic"`, `"canvas"`, `"moodle"`).
#' @param include_solutions Logical; mark exercise solutions as available.
#' @param language Manifest language (`"en"` or `"fr"`).
#'
#' @return A `tutorize_lms_manifest` object.
#' @export
export_lms_manifest <- function(
  input,
  output_file = NULL,
  profile = c("generic", "canvas", "moodle"),
  include_solutions = TRUE,
  language = c("en", "fr")
) {
  profile <- match.arg(profile)
  language <- match.arg(language)

  validate_input(input = input, format = "learnr", assessment = "code", language = language)
  parsed <- parse_input_document(input)

  title <- parsed$front_matter$yaml$title %||% tr("labels.interactive_tutorial", language = language)
  sections <- extract_section_titles(parsed$blocks)
  items <- derive_manifest_items(parsed$blocks, include_solutions = include_solutions)

  manifest <- list(
    schema_version = "1.0",
    profile = profile,
    title = as.character(title),
    language = language,
    sections = sections,
    items = items,
    estimated_minutes = round(length(items) * 3 + length(sections) * 0.5, 1)
  )

  if (profile == "canvas") {
    manifest$vendor <- list(canvas = list(module_name = as.character(title), item_count = length(items)))
  }

  if (profile == "moodle") {
    manifest$vendor <- list(moodle = list(section_count = length(sections), activity_count = length(items)))
  }

  if (is.null(output_file)) {
    stem <- tools::file_path_sans_ext(input)
    output_file <- paste0(stem, "-manifest-", profile, ".json")
  }

  out_dir <- dirname(output_file)
  if (!dir.exists(out_dir)) {
    dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
  }

  ext <- tolower(tools::file_ext(output_file))
  if (ext %in% c("yml", "yaml")) {
    writeLines(yaml::as.yaml(manifest, indent.mapping.sequence = TRUE), output_file, useBytes = TRUE)
  } else {
    jsonlite::write_json(manifest, output_file, auto_unbox = TRUE, pretty = TRUE, null = "null")
  }

  structure(
    list(
      profile = profile,
      output_file = output_file,
      manifest = manifest
    ),
    class = "tutorize_lms_manifest"
  )
}

#' Print method for LMS manifest exports
#'
#' @param x A `tutorize_lms_manifest` object.
#' @param ... Unused.
#'
#' @return `x`, invisibly.
#' @export
print.tutorize_lms_manifest <- function(x, ...) {
  cat("tutorizeR LMS manifest\n")
  cat("- profile: ", x$profile, "\n", sep = "")
  cat("- file:    ", x$output_file, "\n", sep = "")
  cat("- items:   ", length(x$manifest$items), "\n", sep = "")
  cat("- sections:", length(x$manifest$sections), "\n", sep = "")
  invisible(x)
}

#' Export a tutorial-ready package scaffold (opt-in)
#'
#' @param input Source `.Rmd`/`.qmd` file.
#' @param path Parent directory where the package directory will be created.
#' @param package_name Optional package name. Derived from input by default.
#' @param overwrite Logical; replace existing package directory if present.
#'
#' @return Invisibly returns the created package path.
#' @export
export_tutorial_package <- function(input, path = ".", package_name = NULL, overwrite = FALSE) {
  validate_input(input = input, format = "learnr", assessment = "code", language = "en")

  if (is.null(package_name) || !nzchar(package_name)) {
    package_name <- tools::file_path_sans_ext(basename(input))
    package_name <- gsub("[^A-Za-z0-9]", "", package_name)
    package_name <- paste0(package_name, "Tutorial")
  }

  pkg_dir <- file.path(path, package_name)

  if (dir.exists(pkg_dir)) {
    if (!isTRUE(overwrite)) {
      rlang::abort(
        sprintf("Package directory already exists: %s", pkg_dir),
        class = c("tutorizeR_error_validation", "tutorizeR_error")
      )
    }
    unlink(pkg_dir, recursive = TRUE, force = TRUE)
  }

  dir.create(pkg_dir, recursive = TRUE, showWarnings = FALSE)
  dir.create(file.path(pkg_dir, "R"), recursive = TRUE, showWarnings = FALSE)
  dir.create(file.path(pkg_dir, "inst", "tutorials"), recursive = TRUE, showWarnings = FALSE)

  description <- c(
    sprintf("Package: %s", package_name),
    "Type: Package",
    "Title: Tutorial package generated by tutorizeR",
    "Version: 0.0.0.9000",
    "Authors@R: person(given = 'Generated', family = 'ByTutorizeR', role = c('aut', 'cre'), email = 'noreply@example.org')",
    "Description: Tutorial package scaffold generated from a source teaching file.",
    "License: MIT + file LICENSE",
    "Encoding: UTF-8",
    "LazyData: true"
  )

  writeLines(description, file.path(pkg_dir, "DESCRIPTION"), useBytes = TRUE)
  writeLines("exportPattern('^[[:alpha:]]+')", file.path(pkg_dir, "NAMESPACE"), useBytes = TRUE)
  writeLines(c("MIT License", ""), file.path(pkg_dir, "LICENSE"), useBytes = TRUE)

  tut_report <- tutorize(
    input = input,
    output_dir = file.path(pkg_dir, "inst", "tutorials"),
    format = "learnr",
    assessment = "both",
    overwrite = TRUE,
    verbose = FALSE
  )

  writeLines(
    c(
      sprintf("# %s", package_name),
      "",
      "Generated with tutorizeR.",
      "",
      sprintf("Tutorial file: `%s`", basename(tut_report$output_file))
    ),
    file.path(pkg_dir, "README.md"),
    useBytes = TRUE
  )

  invisible(pkg_dir)
}

#' Extract markdown heading titles from parsed blocks
#' @keywords internal
extract_section_titles <- function(blocks) {
  sections <- character()
  for (block in blocks) {
    if (!identical(block$type, "text")) {
      next
    }

    heads <- grep("^#{1,6}\\s+", block$lines, value = TRUE)
    if (length(heads) > 0L) {
      clean <- trimws(sub("^#{1,6}\\s+", "", heads))
      sections <- c(sections, clean)
    }
  }

  sections
}

#' Derive LMS items from parsed chunks
#' @keywords internal
derive_manifest_items <- function(blocks, include_solutions = TRUE) {
  items <- list()
  idx <- 0L

  for (block in blocks) {
    if (!identical(block$type, "chunk")) {
      next
    }

    if (is_setup_chunk(block)) {
      next
    }

    item_type <- NULL

    if (is_mcq_block(block) || is_mcq_ref_block(block)) {
      item_type <- "mcq"
    } else if (is_r_chunk(block)) {
      item_type <- "exercise"
    }

    if (is.null(item_type)) {
      next
    }

    idx <- idx + 1L
    items[[idx]] <- list(
      id = block$label %||% sprintf("item-%03d", idx),
      type = item_type,
      solution_available = isTRUE(include_solutions) && identical(item_type, "exercise")
    )
  }

  items
}
